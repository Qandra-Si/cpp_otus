// -*- mode: c++; coding: utf-8 -*-

/*
Ниже рассмотрен вопрос, который был озвучен в 5 занятии на 30й минуте, а именно
выбрасывание исключений в конструкторах. Вопрос не праздный, часто им
интересуются на собеседованиях. Необходимо понимать как работает программа,
когда встречается с исключением во время инициализации объекта.

Было сказано следующее: "в конструкторе память выделена, конструктор ещё не
завершился, внутри конструктора кидается исключение, исключение покидает
конструктор, конструктор не выполнился в итоге, это означает что объект до конца
не создан, если объект до конца не создан, это означает, что деструктор его
вызывать не нужно".

Последняя фраза "...деструктор его вызывать не нужно" спорная, в контексте "кому
не нужно?" Компилятору или программисту?

Дело в том, что компилятор позаботится о сборке мусора _за_программиста_ и
автоматически вызовет деструкторы полей объекта. Однако компилятор не будет
удалять объекты, которые были динамически размещены в памяти. Память, которую
"временно" занимал объект, который не смог создасться, компилятор также
освободит. Таким образом - деструктор объекта, в конструкторе которого произошло
исключение, действительно вызывать не нужно, технически это так.

---

После запуска программы на экране появится:
field_t ctor(33)
field_t ctor(42)
field_t dtor(33)

---

В итоге: если программист кидает исключения в конструкторе, то именно
программисту _нужно_ позаботиться о сборке мусора, отлове исключений. А
компилятор _уже_ обо всё позаботился.

---

Подробнее см. в стандарте тут http://eel.is/c++draft/except.ctor#3
*/

#include <iostream>
#include <string>


void print(const char * ctx, int val)
{
  std::cout << "field_t " << ctx << "(" << val << ")" << std::endl;
}

struct field_t
{
  int val;
  field_t() = delete;
  field_t(int val) : val(val) { print("ctor", val); }
  ~field_t() { print("dtor", val); }
};

struct crash1_t
{
  field_t f1;
  field_t * f2;
  crash1_t() :
    f1(33), // имитируем выделение памяти для f1.ptr
    f2(new field_t(42)) // выделяем память для f2 и имитируем выделение для f2.ptr
  {
    throw 1;
    // деструктор f1 будет вызван автоматически
    // деструктор f2 вызван не будет
  }
  ~crash1_t()
  {
    std::cout << "Oops! dtor called?!" << std::endl;
  }
};

int main()
{
  try
  {
    crash1_t mem_leak;
  }
  catch(...)
  {
  }
  return 0;
}
