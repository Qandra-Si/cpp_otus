// -*- mode: c++; coding: utf-8 -*-
#include <iostream>
#include <string>


std::string trim(const std::string & s);

/*! \brief Задача №2100. Свадебный обед
*
* https://acm.timus.ru/problem.aspx?space=1&num=2100
*
* Маршалл и Лили женятся! Они отослали всем друзьям приглашения на свадьбу. На
* каждом приглашении можно отметить +one — это значит, что друг хочет прийти со
* своей парой (не из числа приглашённых). Все друзья ответили на приглашения, и
* теперь Лили хочет узнать, на сколько гостей организовывать обед в ресторане.
* Все гости будут сидеть за одним большим столом. Маршалл очень суеверный,
* поэтому если за столом окажутся ровно 13 человек (включая Маршалла и Лили), то
* Лили попросит сотрудников ресторана посадить манекен и обслуживать его наравне
* со всеми. Сколько же потратит молодая пара на этот обед, если обслуживание
* одного человека (или манекена) стоит $100?
*
* Исходные данные: В первой строке вводится одно целое число n — количество
* друзей Маршалла и Лили, которым они отослали приглашение (1 <= n <= 20).
*
* Затем в n строках описываются ответы на приглашения. Каждый ответ имеет вид
* name[+one]. Это имя приглашённого друга и +one, если друг отметил этот
* вариант. Гарантируется, что длина каждого имени не превосходит 20, и каждое
* имя состоит только из букв латинского алфавита.
*
* Результат: Выведите одно целое число — стоимость обеда в долларах.
*/
int main()
{
  int n, guests, people = 2;
  std::cin >> n;
  std::string line;
  while (std::getline(std::cin, line))
  {
    line = trim(line);
    if (line.empty()) continue; // первая строка прочиталась до конца?
    guests = (line.find("+one") == std::string::npos) ? 1 : 2;
    people += guests;
    if (!(--n)) break;
  }
  // на заметку: если (вдруг) придёт один гость без пары, то вся свадьба из 3х
  // человек будет гулять за столом с 39 свободными стульями!
  if (people == 13)
    people++;
  std::cout << people * 100 << std::endl;
  return 0;
}

// к сожалению, getline дочитывает до конца строки после полученного int, т.ч.
// если по следующему имени будут найдены whitespaces, то они попадут на вход
// как пустая или заполненная пробелами строка, - удаляем их
std::string trim(const std::string & s)
{
  const static std::string WHITESPACES = " \n\r\t\f\v";
  const std::size_t from = s.find_first_not_of(WHITESPACES);
  if (from == std::string::npos) return "";
  std::string res = s.substr(from);
  const std::size_t to = res.find_last_not_of(WHITESPACES);
  if (to == std::string::npos) return "";
  return res.substr(0, to + 1);
}
